Okay now i have to summarize how Spring works.

When the client sends a request, then the request is receiver by the servlet container, then he forwards it to one or many Dispatcher servlets, here we have the listeners and filters that filter and alter the requests if needed(now I am not sure if the filters are activated before the request is forwarded to the dispatcher servlet or after). Then the dispatcher has a extension of the Application context(place where all beans(object instances(Repositories, Services, configurations...) created and managed by Spring IOC Container )) and it is called Web Application context. Each Dispatcher servlet has it's own Web Application context and here are the beans of the controllers that this dispatcher servlet manages along with the view resolvers and the Handler mappers. Then when the request is received by the controller then a Handler Adapter calls the methods that map to the corresponding request method and URL. Now when the controller finishes with the request and sends the model or the template, then the Dispatcher servlet. Before the Handler adapter the Locale Resolver and the Multipart Resolver(if we have a multipart request). The handler Adapter then calls the Handler methods that correspond to the method and the URL and if we have some handler method attributes like (session object, request object, model, model or session attributes, request parameters, path variables) then the MethodAttributeResolver will fill those. Now these controller handler methods can return the view,string name of the view template, model, model and view, or a void, ResponseBody if we return a JSON file or a Multipart file.


Okay next part is the Java Persistence API in Spring

When we need to store data permanently we will need a database. Now databases are usually servers on their own and we need to connect to it in order to store data inside or modify.
Now we can do that and do the connection on our own but that is a repeated and exhausting task. That's why we need the JDBC(Java DataBase Connectiovity) that helps us by doing the connection and it's drivers. But we also need some other steps in order to use a database like : compatibility of data , the mapping of a java object to a database format in a table. This is specified by the java persistence API, but this is not actually a implementation. The JPA is implemented by providers like Hybernate, EclipseLink and they are the ones that generate the SQL queries and provide those to the JDBC to be later executed in the database.
But we would need separate Repositories for each mapped entity.
This is abstracted with Spring Data JPA. This will provide us with abstractions for any type of database.
Now the data represented in a object in java is called an Entity. This is the object that is mapped in the database to a table format. Each entity is: synced with the DB(every update on the object is mapped to the DB), unique(every instance must be unique in one of it's attributes and that is the 'primary key'), transactional(update will be aborted during sync if an concurrent error occurs).
In Spring we define a class to be entity with the annotation @Entity and then having a column/attribute with annotation @Id. But normally this id is not generated so we can make it to be automatically generated and added with @GeneratedValue. Now this has some options like: SEQUENCE(global counter that increments and is shared with the whole DB and is internal in the DB system),IDENTITY(counter that is only for that table ), TABLE(global counter that increments but it is different from SEQUENCE because not every DB has support for it and this on creates a table that holds the generated values and looks from that table to generate a new one).
Now if we have object attributes in an entity but we don't want a separate table just for them because they are dependent on the entity and have no use otherwise, then we mark them as @Embeddable on the class and @Embedded on the attribute.
Also we can have relations between entities.
-OneToOne when only single entity is on both sides on the relation. We can make it two sided by using mappedby in the second entity that points to the attribute in the first entity.
-OneToMany when a single entity can relate to multiple others(but the others can relate to only one), we use a collection(list,set,map), for that, also if we want to make double sided then we need to add ManyToOne relation in the destination entity.
-ManyToOne when multiple entity can relate to a single destination entity, we can make double sided by adding OneToMany in the destination entity.
-ManyToMany when multiple entities can relate to multiple other entities. This will automatically create a new table and we can rename that table with @JoinTable. And with JoinCollumn we can specify the column name and also will make the class that has this to have the primary key.

But now we need to understand that when a instance is created it is not instantly synchonised with the database.
We have an interface called EntityManager that manages the entities.
Now when we have an Entity Employee, then the EntityManager creates and calls a singleton object called EntityTransaction that processes every request for a entity atomically.
We also have a Query object that is created each time by the EntityManager when a user want's to execute a custom specified query.
This EntityManager is created for each different Entity (Employee, User, Manager) by the EntityManagerFactory that is created by the Persistence. Now this factory creates a EntityManager for every request and assigns the JDBC connection to it.